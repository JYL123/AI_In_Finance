import { Tensor, Tensor1D, Tensor2D, Tensor3D, Tensor4D, TensorBuffer } from '../tensor';
import { DataType, Rank, ShapeMap, TensorLike, TensorLike1D, TypedArray } from '../types';
declare class ArrayOps {
    static clone<T extends Tensor>(x: T | TensorLike): T;
    static eye(numRows: number, numColumns?: number, batchShape?: [number] | [number, number] | [number, number, number] | [number, number, number, number], dtype?: DataType): Tensor2D;
    static randomNormal<R extends Rank>(shape: ShapeMap[R], mean?: number, stdDev?: number, dtype?: 'float32' | 'int32', seed?: number): Tensor<R>;
    static truncatedNormal<R extends Rank>(shape: ShapeMap[R], mean?: number, stdDev?: number, dtype?: 'float32' | 'int32', seed?: number): Tensor<R>;
    static randomUniform<R extends Rank>(shape: ShapeMap[R], minval?: number, maxval?: number, dtype?: DataType): Tensor<R>;
    static rand<R extends Rank>(shape: ShapeMap[R], randFunction: () => number, dtype?: DataType): Tensor<R>;
    static multinomial(logits: Tensor1D | Tensor2D | TensorLike, numSamples: number, seed?: number, normalized?: boolean): Tensor1D | Tensor2D;
    static oneHot(indices: Tensor1D | TensorLike1D, depth: number, onValue?: number, offValue?: number): Tensor2D;
    static fromPixels(pixels: ImageData | HTMLImageElement | HTMLCanvasElement | HTMLVideoElement, numChannels?: number): Tensor3D;
    static toPixels(img: Tensor2D | Tensor3D | TensorLike, canvas?: HTMLCanvasElement): Promise<Uint8ClampedArray>;
    static reshape<R2 extends Rank>(x: Tensor | TensorLike, shape: ShapeMap[R2]): Tensor<R2>;
    static squeeze<T extends Tensor>(x: Tensor | TensorLike, axis?: number[]): T;
    static cast<T extends Tensor>(x: T | TensorLike, dtype: DataType): T;
    static tile<T extends Tensor>(x: T | TensorLike, reps: number[]): T;
    static pad1d(x: Tensor1D | TensorLike, paddings: [number, number], constantValue?: number): Tensor1D;
    static pad2d(x: Tensor2D | TensorLike, paddings: [[number, number], [number, number]], constantValue?: number): Tensor2D;
    static pad3d(x: Tensor3D | TensorLike, paddings: [[number, number], [number, number], [number, number]], constantValue?: number): Tensor3D;
    static pad4d(x: Tensor4D | TensorLike, paddings: [[number, number], [number, number], [number, number], [number, number]], constantValue?: number): Tensor4D;
    static pad<T extends Tensor>(x: T | TensorLike, paddings: Array<[number, number]>, constantValue?: number): T;
    static stack<T extends Tensor>(tensors: T[] | TensorLike[], axis?: number): Tensor;
    static unstack<T extends Tensor>(x: T | TensorLike, axis?: number): Tensor[];
    static split<T extends Tensor>(x: T | TensorLike, numOrSizeSplits: number[] | number, axis?: number): T[];
    static cumsum<T extends Tensor>(x: Tensor | TensorLike, axis?: number, exclusive?: boolean, reverse?: boolean): T;
    static expandDims<R2 extends Rank>(x: Tensor | TensorLike, axis?: number): Tensor<R2>;
    static buffer<R extends Rank>(shape: ShapeMap[R], dtype?: DataType, values?: TypedArray): TensorBuffer<R>;
    static print<T extends Tensor>(x: T, verbose?: boolean): void;
}
export declare const buffer: typeof ArrayOps.buffer;
export declare const toPixels: typeof ArrayOps.toPixels;
export declare const cast: typeof ArrayOps.cast;
export declare const clone: typeof ArrayOps.clone;
export declare const cumsum: typeof ArrayOps.cumsum;
export declare const expandDims: typeof ArrayOps.expandDims;
export declare const eye: typeof ArrayOps.eye;
export declare const fromPixels: typeof ArrayOps.fromPixels;
export declare const multinomial: typeof ArrayOps.multinomial;
export declare const oneHot: typeof ArrayOps.oneHot;
export declare const pad: typeof ArrayOps.pad;
export declare const pad1d: typeof ArrayOps.pad1d;
export declare const pad2d: typeof ArrayOps.pad2d;
export declare const pad3d: typeof ArrayOps.pad3d;
export declare const pad4d: typeof ArrayOps.pad4d;
export declare const print: typeof ArrayOps.print;
export declare const rand: typeof ArrayOps.rand;
export declare const randomNormal: typeof ArrayOps.randomNormal;
export declare const randomUniform: typeof ArrayOps.randomUniform;
export declare const reshape: typeof ArrayOps.reshape;
export declare const split: typeof ArrayOps.split;
export declare const squeeze: typeof ArrayOps.squeeze;
export declare const stack: typeof ArrayOps.stack;
export declare const tile: typeof ArrayOps.tile;
export declare const truncatedNormal: typeof ArrayOps.truncatedNormal;
export declare const unstack: typeof ArrayOps.unstack;
export {};
