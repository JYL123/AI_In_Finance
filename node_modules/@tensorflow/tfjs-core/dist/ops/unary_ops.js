"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var doc_1 = require("../doc");
var environment_1 = require("../environment");
var tensor_util_1 = require("../tensor_util");
var util = require("../util");
var operation_1 = require("./operation");
var tensor_ops_1 = require("./tensor_ops");
var UnaryOps = (function () {
    function UnaryOps() {
    }
    UnaryOps.neg = function (x) {
        var $x = tensor_util_1.convertToTensor(x, 'x', 'neg');
        var grad = function (dy) {
            return { $x: function () { return dy.neg(); } };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.neg($x); }, { $x: $x }, grad);
    };
    UnaryOps.ceil = function (x) {
        var $x = tensor_util_1.convertToTensor(x, 'x', 'ceil');
        var grad = function (dy) {
            return { $x: function () { return tensor_ops_1.zerosLike(dy); } };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.ceil($x); }, { $x: $x }, grad);
    };
    UnaryOps.floor = function (x) {
        var $x = tensor_util_1.convertToTensor(x, 'x', 'floor');
        var grad = function (dy) {
            return { $x: function () { return tensor_ops_1.zerosLike(dy); } };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.floor($x); }, { $x: $x }, grad);
    };
    UnaryOps.sign = function (x) {
        var $x = tensor_util_1.convertToTensor(x, 'x', 'sign');
        var grad = function (dy) {
            return { $x: function () { return tensor_ops_1.zerosLike(dy); } };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.sign($x); }, { $x: $x }, grad);
    };
    UnaryOps.round = function (x) {
        var $x = tensor_util_1.convertToTensor(x, 'x', 'round');
        var grad = function (dy) {
            return { $x: function () { return tensor_ops_1.zerosLike(dy); } };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.round($x); }, { $x: $x }, grad);
    };
    UnaryOps.exp = function (x) {
        var $x = tensor_util_1.convertToTensor(x, 'x', 'exp');
        var bck = function (dy, saved) {
            var y = saved[0];
            return { $x: function () { return dy.mulStrict(y); } };
        };
        return environment_1.ENV.engine.runKernel(function (backend, save) { return save(backend.exp($x)); }, { $x: $x }, bck);
    };
    UnaryOps.expm1 = function (x) {
        var $x = tensor_util_1.convertToTensor(x, 'x', 'expm1');
        var grad = function (dy) {
            return { $x: function () { return dy.mulStrict($x.exp()); } };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.expm1($x); }, { $x: $x }, grad);
    };
    UnaryOps.log = function (x) {
        var $x = tensor_util_1.convertToTensor(x, 'x', 'log');
        var grad = function (dy) {
            return { $x: function () { return dy.divStrict($x.toFloat()); } };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.log($x); }, { $x: $x }, grad);
    };
    UnaryOps.log1p = function (x) {
        var $x = tensor_util_1.convertToTensor(x, 'x', 'log1p');
        var grad = function (dy) {
            return { $x: function () { return dy.divStrict($x.add(tensor_ops_1.scalar(1))); } };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.log1p($x); }, { $x: $x }, grad);
    };
    UnaryOps.sqrt = function (x) {
        var $x = tensor_util_1.convertToTensor(x, 'x', 'sqrt');
        var grad = function (dy) {
            return { $x: function () { return dy.divStrict($x.toFloat().sqrt().mul(tensor_ops_1.scalar(2))); } };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.sqrt($x); }, { $x: $x }, grad);
    };
    UnaryOps.rsqrt = function (x) {
        var $x = tensor_util_1.convertToTensor(x, 'x', 'rsqrt');
        var grad = function (dy) {
            return { $x: function () { return dy.divStrict($x.pow(tensor_ops_1.scalar(1.5)).mul(tensor_ops_1.scalar(2))).neg(); } };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.rsqrt($x); }, { $x: $x }, grad);
    };
    UnaryOps.square = function (x) {
        var $x = tensor_util_1.convertToTensor(x, 'x', 'square');
        var grad = function (dy) {
            return { $x: function () { return dy.mulStrict($x.toFloat().mul(tensor_ops_1.scalar(2))); } };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.square($x); }, { $x: $x }, grad);
    };
    UnaryOps.reciprocal = function (x) {
        var $x = tensor_util_1.convertToTensor(x, 'x', 'reciprocal');
        var grad = function (dy) {
            return { $x: function () { return dy.divStrict($x.square().neg()); } };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.reciprocal($x); }, { $x: $x }, grad);
    };
    UnaryOps.abs = function (x) {
        var $x = tensor_util_1.convertToTensor(x, 'x', 'abs');
        var grad = function (dy) {
            return { $x: function () { return dy.mulStrict($x.toFloat().step(-1)); } };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.abs($x); }, { $x: $x }, grad);
    };
    UnaryOps.clipByValue = function (x, clipValueMin, clipValueMax) {
        var $x = tensor_util_1.convertToTensor(x, 'x', 'clipByValue');
        util.assert((clipValueMin <= clipValueMax), "Error in clip: min (" + clipValueMin + ") must be " +
            ("less than or equal to max (" + clipValueMax + ")."));
        var grad = function (dy) {
            return {
                $x: function () { return dy.where($x.greaterEqual(tensor_ops_1.scalar(clipValueMin))
                    .logicalAnd($x.lessEqual(tensor_ops_1.scalar(clipValueMax))), tensor_ops_1.zerosLike(dy)); },
            };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.clip($x, clipValueMin, clipValueMax); }, { $x: $x }, grad);
    };
    UnaryOps.sigmoid = function (x) {
        var $x = tensor_util_1.convertToTensor(x, 'x', 'sigmoid');
        var grad = function (dy, saved) {
            var y = saved[0];
            return { $x: function () { return dy.mulStrict(y.mul(tensor_ops_1.scalar(1).sub(y))); } };
        };
        return environment_1.ENV.engine.runKernel(function (backend, save) { return save(backend.sigmoid($x)); }, { $x: $x }, grad);
    };
    UnaryOps.logSigmoid = function (x) {
        var $x = tensor_util_1.convertToTensor(x, 'x', 'logSigmoid');
        var grad = function (dy) {
            return { $x: function () { return dy.mulStrict($x.neg().sigmoid()); } };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.softplus($x.neg()).neg(); }, { $x: $x }, grad);
    };
    UnaryOps.softplus = function (x) {
        var $x = tensor_util_1.convertToTensor(x, 'x', 'softplus');
        var grad = function (dy) {
            return { $x: function () { return dy.mulStrict($x.sigmoid()); } };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.softplus($x); }, { $x: $x }, grad);
    };
    UnaryOps.sin = function (x) {
        var $x = tensor_util_1.convertToTensor(x, 'x', 'sin');
        var grad = function (dy) {
            return { $x: function () { return $x.toFloat().cos().mulStrict(dy); } };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.sin($x); }, { $x: $x }, grad);
    };
    UnaryOps.cos = function (x) {
        var $x = tensor_util_1.convertToTensor(x, 'x', 'cos');
        var grad = function (dy) {
            return { $x: function () { return $x.toFloat().sin().neg().mulStrict(dy); } };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.cos($x); }, { $x: $x }, grad);
    };
    UnaryOps.tan = function (x) {
        var $x = tensor_util_1.convertToTensor(x, 'x', 'tan');
        var grad = function (dy) {
            return { $x: function () { return dy.divStrict($x.cos().square()); } };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.tan($x); }, { $x: $x }, grad);
    };
    UnaryOps.asin = function (x) {
        var $x = tensor_util_1.convertToTensor(x, 'x', 'asin');
        var grad = function (dy) {
            return {
                $x: function () { return dy.divStrict(tensor_ops_1.scalar(1).sub($x.toFloat().square()).sqrt()); }
            };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.asin($x); }, { $x: $x }, grad);
    };
    UnaryOps.acos = function (x) {
        var $x = tensor_util_1.convertToTensor(x, 'x', 'acos');
        var grad = function (dy) {
            return {
                $x: function () {
                    return dy.divStrict(tensor_ops_1.scalar(1).sub($x.toFloat().square()).sqrt()).neg();
                }
            };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.acos($x); }, { $x: $x }, grad);
    };
    UnaryOps.atan = function (x) {
        var $x = tensor_util_1.convertToTensor(x, 'x', 'atan');
        var grad = function (dy) {
            return { $x: function () { return dy.divStrict(tensor_ops_1.scalar(1).add($x.toFloat().square())); } };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.atan($x); }, { $x: $x }, grad);
    };
    UnaryOps.sinh = function (x) {
        var $x = tensor_util_1.convertToTensor(x, 'x', 'sinh');
        var grad = function (dy) {
            return { $x: function () { return $x.toFloat().cosh().mulStrict(dy); } };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.sinh($x); }, { $x: $x }, grad);
    };
    UnaryOps.cosh = function (x) {
        var $x = tensor_util_1.convertToTensor(x, 'x', 'cosh');
        var grad = function (dy) {
            return { $x: function () { return $x.toFloat().sinh().mulStrict(dy); } };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.cosh($x); }, { $x: $x }, grad);
    };
    UnaryOps.tanh = function (x) {
        var $x = tensor_util_1.convertToTensor(x, 'x', 'tanh');
        var grad = function (dy, saved) {
            var y = saved[0];
            return { $x: function () { return tensor_ops_1.scalar(1).sub(y.square()).mulStrict(dy); } };
        };
        return environment_1.ENV.engine.runKernel(function (backend, save) { return save(backend.tanh($x)); }, { $x: $x }, grad);
    };
    UnaryOps.asinh = function (x) {
        var $x = tensor_util_1.convertToTensor(x, 'x', 'asinh');
        var grad = function (dy) {
            return {
                $x: function () { return dy.divStrict(tensor_ops_1.scalar(1).add($x.toFloat().square()).sqrt()); }
            };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.asinh($x); }, { $x: $x }, grad);
    };
    UnaryOps.acosh = function (x) {
        var $x = tensor_util_1.convertToTensor(x, 'x', 'acosh');
        var grad = function (dy) {
            return {
                $x: function () { return dy.divStrict($x.toFloat().square().sub(tensor_ops_1.scalar(1)).sqrt()); }
            };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.acosh($x); }, { $x: $x }, grad);
    };
    UnaryOps.atanh = function (x) {
        var $x = tensor_util_1.convertToTensor(x, 'x', 'atanh');
        var grad = function (dy) {
            return { $x: function () { return dy.divStrict(tensor_ops_1.scalar(1).sub($x.toFloat().square())); } };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.atanh($x); }, { $x: $x }, grad);
    };
    UnaryOps.erf = function (x) {
        var $x = tensor_util_1.convertToTensor(x, 'x', 'erf');
        util.assert($x.dtype === 'int32' || $x.dtype === 'float32', 'Input dtype must be `int32` or `float32`.');
        if ($x.dtype === 'int32') {
            $x = $x.toFloat();
        }
        var grad = function (dy) {
            return {
                $x: function () { return dy.mulStrict(tensor_ops_1.scalar(2 / Math.sqrt(Math.PI)).mul($x.square().neg().exp())); }
            };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.erf($x); }, { $x: $x }, grad);
    };
    UnaryOps.step = function (x, alpha) {
        if (alpha === void 0) { alpha = 0.0; }
        var $x = tensor_util_1.convertToTensor(x, 'x', 'step');
        var grad = function (dy) {
            return { $x: function () { return tensor_ops_1.zerosLike(dy); } };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.step($x, alpha); }, { $x: $x }, grad);
    };
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Basic math' })
    ], UnaryOps, "neg", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Basic math' })
    ], UnaryOps, "ceil", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Basic math' })
    ], UnaryOps, "floor", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Basic math' })
    ], UnaryOps, "sign", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Basic math' })
    ], UnaryOps, "round", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Basic math' })
    ], UnaryOps, "exp", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Basic math' })
    ], UnaryOps, "expm1", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Basic math' })
    ], UnaryOps, "log", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Basic math' })
    ], UnaryOps, "log1p", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Basic math' })
    ], UnaryOps, "sqrt", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Basic math' })
    ], UnaryOps, "rsqrt", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Basic math' })
    ], UnaryOps, "square", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Basic math' })
    ], UnaryOps, "reciprocal", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Basic math' })
    ], UnaryOps, "abs", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Basic math' })
    ], UnaryOps, "clipByValue", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Basic math' })
    ], UnaryOps, "sigmoid", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Basic math' })
    ], UnaryOps, "logSigmoid", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Basic math' })
    ], UnaryOps, "softplus", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Basic math' })
    ], UnaryOps, "sin", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Basic math' })
    ], UnaryOps, "cos", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Basic math' })
    ], UnaryOps, "tan", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Basic math' })
    ], UnaryOps, "asin", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Basic math' })
    ], UnaryOps, "acos", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Basic math' })
    ], UnaryOps, "atan", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Basic math' })
    ], UnaryOps, "sinh", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Basic math' })
    ], UnaryOps, "cosh", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Basic math' })
    ], UnaryOps, "tanh", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Basic math' })
    ], UnaryOps, "asinh", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Basic math' })
    ], UnaryOps, "acosh", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Basic math' })
    ], UnaryOps, "atanh", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Basic math' })
    ], UnaryOps, "erf", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Basic math' })
    ], UnaryOps, "step", null);
    return UnaryOps;
}());
exports.abs = operation_1.op(UnaryOps.abs);
exports.acos = operation_1.op(UnaryOps.acos);
exports.acosh = operation_1.op(UnaryOps.acosh);
exports.asin = operation_1.op(UnaryOps.asin);
exports.asinh = operation_1.op(UnaryOps.asinh);
exports.atan = operation_1.op(UnaryOps.atan);
exports.atanh = operation_1.op(UnaryOps.atanh);
exports.ceil = operation_1.op(UnaryOps.ceil);
exports.clipByValue = operation_1.op(UnaryOps.clipByValue);
exports.cos = operation_1.op(UnaryOps.cos);
exports.cosh = operation_1.op(UnaryOps.cosh);
exports.erf = operation_1.op(UnaryOps.erf);
exports.exp = operation_1.op(UnaryOps.exp);
exports.expm1 = operation_1.op(UnaryOps.expm1);
exports.floor = operation_1.op(UnaryOps.floor);
exports.log = operation_1.op(UnaryOps.log);
exports.log1p = operation_1.op(UnaryOps.log1p);
exports.logSigmoid = operation_1.op(UnaryOps.logSigmoid);
exports.neg = operation_1.op(UnaryOps.neg);
exports.reciprocal = operation_1.op(UnaryOps.reciprocal);
exports.round = operation_1.op(UnaryOps.round);
exports.rsqrt = operation_1.op(UnaryOps.rsqrt);
exports.sigmoid = operation_1.op(UnaryOps.sigmoid);
exports.sign = operation_1.op(UnaryOps.sign);
exports.sin = operation_1.op(UnaryOps.sin);
exports.sinh = operation_1.op(UnaryOps.sinh);
exports.softplus = operation_1.op(UnaryOps.softplus);
exports.sqrt = operation_1.op(UnaryOps.sqrt);
exports.square = operation_1.op(UnaryOps.square);
exports.step = operation_1.op(UnaryOps.step);
exports.tan = operation_1.op(UnaryOps.tan);
exports.tanh = operation_1.op(UnaryOps.tanh);
//# sourceMappingURL=unary_ops.js.map